#!/usr/bin/env perl

use warnings;
use strict;

use File::Spec;
use Getopt::Long qw(GetOptions);

# Pull in code from the common module
use FindBin;
use lib "$FindBin::Bin/common";
use ash_common;


## ORGANIZATION
## This script is organized into 3 sections:
## 1) GLOBAL INITIALIZATION - initialize some useful global constants
## 2) EXECUTION LOGIC - the actual command logic, ie. 'main'
## 3) SUBROUTINES - subroutines used by the command logic


########## BEGIN GLOBAL INITIALIZATION ##########
my $ansi_red = ash_common::ansi_red();
my $ansi_green = ash_common::ansi_green();
my $ansi_magenta = ash_common::ansi_magenta();
my $ansi_bold = ash_common::ansi_bold();
my $ansi_reset = ash_common::ansi_reset();
my $ansi_bunl = ash_common::ansi_begin_underln();
my $ansi_eunl = ash_common::ansi_end_underln();

my $no_colors_stdout = ash_common::is_no_colors_stdout();
my $red_stdout = $no_colors_stdout ? "" : $ansi_red;
my $green_stdout = $no_colors_stdout ? "" : $ansi_green;
my $magenta_stdout = $no_colors_stdout ? "" : $ansi_magenta;
my $bold_stdout = $no_colors_stdout ? "" : $ansi_bold;
my $reset_stdout = $no_colors_stdout ? "" : $ansi_reset;
my $bunl_stdout = $no_colors_stdout ? "" : $ansi_bunl;
my $eunl_stdout = $no_colors_stdout ? "" : $ansi_eunl;

my $no_colors_stderr = ash_common::is_no_colors_stderr();
my $red_stderr = $no_colors_stderr ? "" : $ansi_red;
my $green_stderr = $no_colors_stderr ? "" : $ansi_green;
my $magenta_stderr = $no_colors_stderr ? "" : $ansi_magenta;
my $bold_stderr = $no_colors_stderr ? "" : $ansi_bold;
my $reset_stderr = $no_colors_stderr ? "" : $ansi_reset;
my $bunl_stderr = $no_colors_stderr ? "" : $ansi_bunl;
my $eunl_stderr = $no_colors_stderr ? "" : $ansi_eunl;

my $ash_path;
my $skip_paging;
my $quiet;

my $program_name = 'ash';
my $program_version = "$ash_common::ATLAS_SHELL_TOOLS_VERSION ($program_name program)";

my $cfgpreset_start = 'cfg:preset';

########## END GLOBAL INITIALIZATION ##########


########## BEGIN SUBROUTINES ##########

sub ash_unrecognized_command_message_and_exit {
    my $command = shift;
    ash_common::error_output($program_name, "no such command ${bold_stderr}${command}${reset_stderr}");
    print STDERR "Try '${bold_stderr}${program_name} --list${reset_stderr}' for a list of commands.\n";
    print STDERR "Try '${bold_stderr}${program_name} --help${reset_stderr}' for more information.\n";
    exit 127;
}

sub ash_show_contextual_help_menu_and_exit {
    my $context = shift;
    my $skip_paging = shift;
    my $ash_path = shift;

    unless (defined $skip_paging) {
        $skip_paging = 0;
    }

    my %subcommand_classes = get_subcommand_to_class_hash($ash_path);
    my $subcommand_class = $subcommand_classes{$context};

    unless (defined $subcommand_class) {
        ash_unrecognized_command_message_and_exit($context);
    }

    my $full_path_to_modules_folder = File::Spec->catfile($ash_path, $ash_common::MODULES_FOLDER, '*');

    my $java_command = "java -Xms2G -Xmx2G ".
                   "-cp \"${full_path_to_modules_folder}\" ".
                   "-Dlog4j.rootLogger=ERROR ".
                   "${subcommand_class} --help ";

    if (ash_common::is_no_colors_stdout()) {
        $java_command = $java_command . "$ash_common::JAVA_NO_COLOR_STDOUT ";
    } else {
        $java_command = $java_command . "$ash_common::JAVA_COLOR_STDOUT ";
    }

    if (ash_common::is_no_colors_stderr()) {
        $java_command = $java_command . "$ash_common::JAVA_NO_COLOR_STDERR ";
    } else {
        $java_command = $java_command . "$ash_common::JAVA_COLOR_STDERR ";
    }

    $java_command = $java_command . "$ash_common::JAVA_NO_USE_PAGER ";

    my $terminal_width = ash_common::terminal_width();
    $java_command = $java_command . "$terminal_width ";
    $java_command = $java_command . "$ash_common::JAVA_MARKER_SENTINEL ";

    my $pager_command = ash_common::get_pager();
    unless (defined $pager_command) {
        $skip_paging = 1;
    }

    if ($skip_paging) {
        my $output = `$java_command`;
        print "$output";
    } else {
        open PAGER, "|${pager_command}" or die $!;
        my $output = `$java_command`;
        print PAGER "$output";
    }

    exit 0;
}

sub ash_show_class_of_and_exit {
    my $ash_path = shift;
    my $class_of = shift;

    my %subcommand_classes = ash_common::get_subcommand_to_class_hash($ash_path);
    my $subcommand_class = $subcommand_classes{$class_of};

    unless (defined $subcommand_class) {
        ash_unrecognized_command_message_and_exit($class_of);
    }

    print "$subcommand_class\n";
    exit 0;
}

sub ash_list_subcommands_and_exit {
    my $ash_path = shift;
    my $skip_paging = shift;

    unless (defined $skip_paging) {
        $skip_paging = 0;
    }

    my %subcommand_desc = ash_common::get_subcommand_to_description_hash($ash_path);
    my $pager_command = ash_common::get_pager();

    unless (defined $pager_command) {
        $skip_paging = 1;
    }

    if ($skip_paging) {
        print "\n";
        print "${bold_stdout}AVAILABLE COMMANDS${reset_stdout}\n";
        print "See the help page for a command with ${bold_stdout}${program_name} --help <command>${reset_stdout}.\n\n";
        foreach my $subcommand (sort {lc $a cmp lc $b} keys %subcommand_desc) {
            print "    ${bold_stdout}$subcommand${reset_stdout}\n";
            print "        $subcommand_desc{$subcommand}\n\n";
        }
        print "\n";
    }
    else {
        open PAGER, "|${pager_command}" or die $!;
        print PAGER "${bold_stdout}AVAILABLE COMMANDS${reset_stdout}\n";
        print PAGER "See the help page for a command with ${bold_stdout}${program_name} --help <command>${reset_stdout}.\n";
        print PAGER "You can open a new page directly from this window with ${bold_stdout}!ash --help <command>${reset_stdout}.\n\n";
        foreach my $subcommand (sort {lc $a cmp lc $b} keys %subcommand_desc) {
            print PAGER "    ${bold_stdout}$subcommand${reset_stdout}\n";
            print PAGER "        $subcommand_desc{$subcommand}\n\n";
        }
    }

    exit 0;
}

sub ash_cfgpreset {
    my $argv_ref = shift;

    my @argv = @{$argv_ref};
    my %subcommand_classes = get_subcommand_to_class_hash($ash_path);
    my $current_namespace = ash_common::get_namespace($ash_path);
    my $success = 1;

    my $directive_and_context = shift @argv;
    unless (defined $directive_and_context) {
        ash_common::error_output($program_name, "${cfgpreset_start} requires a directive");
        print STDERR "Try ${bold_stderr}save${reset_stderr}, ${bold_stderr}show${reset_stderr}, ${bold_stderr}remove${reset_stderr}, ${bold_stderr}edit${reset_stderr}, ${bold_stderr}copy${reset_stderr}, or ${bold_stderr}namespace${reset_stderr}.\n";
        return 0;
    }

    my @split = split(":", $directive_and_context, 2);
    my $directive = $split[0];
    my $command_context = $split[1];

    if ($directive eq 'save') {
        unless (defined $command_context) {
            ash_common::error_output($program_name, "must specify a command context like ${bold_stderr}save:MyCommand${reset_stderr}");
            return 0;
        }
        unless (defined $subcommand_classes{$command_context}) {
            ash_common::error_output($program_name, "no such command ${bold_stderr}${command_context}${reset_stderr}");
            return 0;
        }
        my $preset = shift @argv;
        unless (defined $preset) {
            ash_common::error_output($program_name, "must specify a preset name");
            print STDERR "Try \'${bold_stderr}ash cfg:preset save:${command_context} <preset>${reset_stderr}\'.\n";
            return 0;
        }
        $success = ash_common::save_preset($ash_path, $program_name, $quiet, $preset, $command_context, $current_namespace, \@argv);
    } elsif ($directive eq 'show') {
        unless (defined $command_context) {
            ash_common::error_output($program_name, "must specify a command context like ${bold_stderr}show:MyCommand${reset_stderr}");
            return 0;
        }
        unless (defined $subcommand_classes{$command_context}) {
            ash_common::error_output($program_name, "no such command ${bold_stderr}${command_context}${reset_stderr}");
            return 0;
        }
        my $preset = shift @argv;
        if (defined $preset) {
            $success = ash_common::show_preset($ash_path, $program_name, $quiet, $preset, $command_context, $current_namespace);
        } else {
            $success = ash_common::all_presets($ash_path, $program_name, $quiet, $command_context, $current_namespace);
        }
    } elsif ($directive eq 'remove') {
        unless (defined $command_context) {
            ash_common::error_output($program_name, "must specify a command context like ${bold_stderr}remove:MyCommand${reset_stderr}");
            return 0;
        }
        unless (defined $subcommand_classes{$command_context}) {
            ash_common::error_output($program_name, "no such command ${bold_stderr}${command_context}${reset_stderr}");
            return 0;
        }
        my $preset = shift @argv;
        if (defined $preset) {
            $success = ash_common::remove_preset($ash_path, $program_name, $quiet, $preset, $command_context, $current_namespace);
        } else {
            $success = ash_common::remove_all_presets_for_command($ash_path, $program_name, $quiet, $command_context, $current_namespace);
        }
    } elsif ($directive eq 'edit') {
        unless (defined $command_context) {
            ash_common::error_output($program_name, "must specify a command context like ${bold_stderr}edit:MyCommand${reset_stderr}");
            return 0;
        }
        unless (defined $subcommand_classes{$command_context}) {
            ash_common::error_output($program_name, "no such command ${bold_stderr}${command_context}${reset_stderr}");
            return 0;
        }
        my $preset = shift @argv;
        unless (defined $preset) {
            ash_common::error_output($program_name, "must specify a preset name");
            print STDERR "Try \'${bold_stderr}ash cfg:preset edit:${command_context} <preset>${reset_stderr}\'.\n";
            return 0;
        }
        $success = ash_common::edit_preset($ash_path, $program_name, $quiet, $preset, $command_context, $current_namespace);
    } elsif ($directive eq 'copy') {
        unless (defined $command_context) {
            ash_common::error_output($program_name, "must specify a command context like ${bold_stderr}copy:MyCommand${reset_stderr}");
            return 0;
        }
        unless (defined $subcommand_classes{$command_context}) {
            ash_common::error_output($program_name, "no such command ${bold_stderr}${command_context}${reset_stderr}");
            return 0;
        }
        my $src_preset = shift @argv;
        my $dest_preset = shift @argv;
        unless (defined $src_preset) {
            ash_common::error_output($program_name, "must specify a source preset name");
            print STDERR "Try \'${bold_stderr}ash cfg:preset copy:${command_context} <source-preset> <destination-preset>${reset_stderr}\'.\n";
            return 0;
        }
        unless (defined $dest_preset) {
            ash_common::error_output($program_name, "must specify a destination preset name");
            print STDERR "Try \'${bold_stderr}ash cfg:preset copy:${command_context} <source-preset> <destination-preset>${reset_stderr}\'.\n";
            return 0;
        }
        $success = ash_common::copy_preset($ash_path, $program_name, $quiet, $src_preset, $dest_preset, $command_context, $current_namespace);
    } elsif ($directive eq 'namespace') {
        $success = ash_cfgpreset_namespace($current_namespace, \@argv);
    } else {
        ash_common::error_output($program_name, "unrecognized ${bold_stderr}${cfgpreset_start}${reset_stderr} directive '${bold_stderr}${directive}${reset_stderr}'");
        print STDERR "Try ${bold_stderr}save${reset_stderr}, ${bold_stderr}show${reset_stderr}, ${bold_stderr}remove${reset_stderr}, ${bold_stderr}edit${reset_stderr}, ${bold_stderr}copy${reset_stderr}, or ${bold_stderr}namespace${reset_stderr}.\n";
        return 0;
    }

    return $success;
}

sub ash_cfgpreset_namespace {
    my $current_namespace = shift;
    my $argv_ref = shift;

    my @argv = @{$argv_ref};
    my %subcommand_classes = get_subcommand_to_class_hash($ash_path);
    my $success = 1;

    my $subdirective = shift @argv;

    unless (defined $subdirective) {
        ash_common::error_output($program_name, "${bold_stderr}${cfgpreset_start} namespace${reset_stderr} requires a subdirective");
        print STDERR "Try ${bold_stderr}list${reset_stderr}, ${bold_stderr}use${reset_stderr}, ${bold_stderr}create${reset_stderr}, or ${bold_stderr}remove${reset_stderr}.\n";
        return 0;
    }

    if ($subdirective eq 'list') {
        $success = ash_common::all_namespaces($ash_path, $program_name, $quiet);
    } elsif ($subdirective eq 'use') {
        my $namespace = shift @argv;
        unless (defined $namespace) {
            ash_common:error_output($program_name, "must specify a namespace");
            print STDERR "Try \'${bold_stderr}ash cfg:preset namespace use <namespace>${reset_stderr}\'.\n";
            return 0;
        }
        $success = ash_common::use_namespace($ash_path, $program_name, $quiet, $namespace);
    } elsif ($subdirective eq 'create') {
        my $new_namespace = shift @argv;
        unless (defined $new_namespace) {
            ash_common:error_output($program_name, "must specify a new namespace");
            print STDERR "Try \'${bold_stderr}ash cfg:preset namespace create <new-namespace>${reset_stderr}\'.\n";
            return 0;
        }
        $success = ash_common::create_namespace($ash_path, $program_name, $quiet, $new_namespace);
    } elsif ($subdirective eq 'remove') {
        my $namespace = shift @argv;
        unless (defined $namespace) {
            ash_common:error_output($program_name, "must specify a namespace");
            print STDERR "Try \'${bold_stderr}ash cfg:preset namespace remove <namespace>${reset_stderr}\'.\n";
            return 0;
        }
        $success = ash_common::remove_namespace($ash_path, $program_name, $quiet, $namespace);
    } else {
        ash_common::error_output($program_name, "unrecognized ${bold_stderr}${cfgpreset_start} namespace${reset_stderr} subdirective '${bold_stderr}${subdirective}${reset_stderr}'");
        print STDERR "Try ${bold_stderr}list${reset_stderr}, ${bold_stderr}create${reset_stderr}, ${bold_stderr}use${reset_stderr}, or ${bold_stderr}remove${reset_stderr}.\n";
        return 0;
    }

    return 1;
}

########## END SUBROUTINES ##########


########## BEGIN EXECUTION LOGIC ##########

$ash_path = ash_common::create_data_directory();

# Handle ash global options. Global options are options that come before the
# supplied subcommand. Subcommand options are handled by the command implementation.
my $memory = '8G';
my $help_argument;
my $show_list;
my $class_of;
my $save_preset;
my $use_preset;
my $remove_preset;
my $all_presets;
my $show_preset;
my $edit_preset;
my $cfg_preset;
Getopt::Long::Configure(qw(no_ignore_case_always));
GetOptions(
    "no-pager" => \$skip_paging,
    "memory|m=s" => \$memory,
    "help|h:s" => \$help_argument,
    "version|V" => sub { print "$program_version\n"; exit 0; },
    "quiet|q" => \$quiet,
    "list|l" => \$show_list,
    "class-of=s" => \$class_of,
    "preset|p=s" => \$use_preset,
    "save-preset=s" => \$save_preset,
    # This callback occurs the first time we see a non-option argument.
    # In our case, this will be the either the 'cfg:preset' command or the
    # target subcommand.
    "<>" => sub {
        my($arg) = @_;
        if ($arg eq $cfgpreset_start) {
            $cfg_preset = 1;
            die "!FINISH";
        }
        if ($arg =~ m{^-}) {
            unless ($arg eq '-') {
                die "FATAL error: unhandled global option $arg";
            }
        }
        # add the subcommand to the front of ARGV
        unshift @ARGV, $arg;
        die "!FINISH";
    }
) or ash_common::getopt_failure_and_exit($program_name);

# Handle the case where the user supplied a --help flag with no arg.
# We can show this without doing any other verification.
# Just display the man page and exit.
if (defined $help_argument) {
    if ($help_argument eq '') {
        my $man_command = ash_common::get_man($skip_paging);
        unless (defined $man_command) {
            ash_common::error_output($program_name, "could not obtain \'man\' command");
            print STDERR "Please ensure a valid \'man\' command is on your path.\n";
            exit 1;
        }
        system("$man_command $program_name");
        my $exitcode = $? >> 8;
        if ($exitcode != 0) {
            exit 1;
        }
        exit 0;
    }
}

my %modules = ash_common::get_module_to_status_hash($ash_path);

# If there are no modules, let's throw an error
unless (keys %modules) {
    ash_common::error_output($program_name, 'found no installed modules');
    print STDERR "Try '${bold_stderr}ash-config install /path/to/module.jar${reset_stderr}' to install a module.\n";
    exit 1;
}

my @activated_modules = ash_common::get_activated_modules(\%modules);

# If there are modules but none are active, let's warn the user
if (scalar @activated_modules == 0) {
    ash_common::error_output($program_name, 'no activated module');
    print STDERR "Try '${bold_stderr}ash-config list${reset_stderr}' to see all installed modules.\n";
    print STDERR "Then try '${bold_stderr}ash-config activate <module>${reset_stderr}' to activate.\n";
    exit 1;
}

my $index_path = File::Spec->catfile($ash_path, $ash_common::ACTIVE_INDEX_PATH);
unless (-f $index_path) {
    ash_common::error_output($program_name, 'could not find active module index');
    print STDERR "Try '${bold_stderr}ash-config sync${reset_stderr}' to resolve.\n";
    exit 1;
}

# Handle the case where the user supplied the cfg:preset arg. When this happens,
# then any arg after it should be passed forward to the cfg:preset handler
if (defined $cfg_preset) {
    my $success = ash_cfgpreset(\@ARGV);
    unless ($success) {
        exit 1;
    }
    exit 0;
}

# Handle case where user entered --help=TOPIC flag
# We waited until after verifying that a command index exists
if (defined $help_argument) {
    unless ($help_argument eq '') {
        ash_show_contextual_help_menu_and_exit($help_argument, $skip_paging, $ash_path);
    }
}

my %subcommand_classes = get_subcommand_to_class_hash($ash_path);

# Handle --class-of option
if (defined $class_of) {
    ash_show_class_of_and_exit($ash_path, $class_of);
}

# Handle --list option
if (defined $show_list) {
    ash_list_subcommands_and_exit($ash_path, $skip_paging);
}

# All global options have been processed, so shift the subcommand off of ARGV
my $subcommand = shift @ARGV;

unless (defined $subcommand) {
    ash_common::error_output($program_name, "missing required command or option");
    print STDERR "Try '${bold_stderr}${program_name} --list${reset_stderr}' for a list of commands.\n";
    print STDERR "Try '${bold_stderr}${program_name} --help${reset_stderr}' for more information.\n";
    exit 1;
}

my $subcommand_class = $subcommand_classes{$subcommand};

# Case where the user entered an invalid subcommand
unless (defined $subcommand_class) {
    ash_unrecognized_command_message_and_exit($subcommand);
}

# Set @new_argv to @ARGV for now. @new_argv will get overriden by an applied
# preset if the user supplied one.
my @new_argv = @ARGV;
my $current_namespace = ash_common::get_namespace($ash_path);

# Check if a preset is being saved or used. We check for preset application
# first, and apply it if necessary. We then check for a preset save. This allows
# users to easily extend presets they have already created by applying and
# saving in a single step.
if (defined $use_preset) {
    @new_argv = ash_common::apply_preset_or_exit($ash_path, $program_name, $quiet, $use_preset, $subcommand, $current_namespace, \@ARGV);
}

if (defined $save_preset) {
    my $success = ash_common::save_preset($ash_path, $program_name, $quiet, $save_preset, $subcommand, $current_namespace, \@new_argv);
    unless ($success) {
        exit 1;
    }
    print "Launching command ${bold_stdout}${subcommand}${reset_stdout}...\n\n";
}

# Set up the subcommand to execute using the JVM
my $full_path_to_modules_folder = File::Spec->catfile($ash_path, $ash_common::MODULES_FOLDER, '*');
my $full_path_to_log4j = File::Spec->catfile($ash_path, $ash_common::LOG4J_FILE_PATH);
my $java_command = "java -Xms$memory -Xmx$memory ".
                   "-cp \"${full_path_to_modules_folder}\" ".
                   "-Dlog4j.configuration=file:${full_path_to_log4j} ".
                   "${subcommand_class} ";

# Surround each arg in quotes in case it contains whitespace
foreach my $arg (@new_argv) {
    $java_command = $java_command . '"' . $arg . '" ';
}

# Append the special TTY formatting sentinel arguments
if (ash_common::is_no_colors_stdout()) {
    $java_command = $java_command . "$ash_common::JAVA_NO_COLOR_STDOUT ";
} else {
    $java_command = $java_command . "$ash_common::JAVA_COLOR_STDOUT ";
}

if (ash_common::is_no_colors_stderr()) {
    $java_command = $java_command . "$ash_common::JAVA_NO_COLOR_STDERR ";
} else {
    $java_command = $java_command . "$ash_common::JAVA_COLOR_STDERR ";
}

if ($skip_paging) {
    $java_command = $java_command . "$ash_common::JAVA_NO_USE_PAGER ";
} else {
    $java_command = $java_command . "$ash_common::JAVA_USE_PAGER ";
}

my $terminal_width = ash_common::terminal_width();
$java_command = $java_command . "$terminal_width ";
$java_command = $java_command . "$ash_common::JAVA_MARKER_SENTINEL ";

system($java_command);
my $exitcode = $? >> 8;
exit $exitcode;


########## END EXECUTION LOGIC ##########
