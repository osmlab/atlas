#!/usr/bin/env perl

use warnings;
use strict;

use Getopt::Long qw(GetOptions);
use File::Basename;
use File::Copy qw(copy);
use File::Spec;
use File::Path;

# Pull in code from the common module
use FindBin;
use lib "$FindBin::Bin/common";
use ash_common;


## ORGANIZATION
## This script is organized into 3 sections:
## 1) GLOBAL INITIALIZATION - initialize some useful global constants
## 2) SUBROUTINES - helper subroutines
## 3) COMMAND SUBROUTINES - subcommand execution subroutines
## 4) EXECUTION LOGIC - the actual command logic, ie. 'main'

########## BEGIN GLOBAL INITIALIZATION ##########
my $ansi_red = ash_common::ansi_red();
my $ansi_green = ash_common::ansi_green();
my $ansi_magenta = ash_common::ansi_magenta();
my $ansi_bold = ash_common::ansi_bold();
my $ansi_blink = ash_common::ansi_blink();
my $ansi_reset = ash_common::ansi_reset();
my $ansi_bunl = ash_common::ansi_begin_underln();
my $ansi_eunl = ash_common::ansi_end_underln();

my $no_colors_stdout = ash_common::is_no_colors_stdout();
my $red_stdout = $no_colors_stdout ? "" : $ansi_red;
my $green_stdout = $no_colors_stdout ? "" : $ansi_green;
my $magenta_stdout = $no_colors_stdout ? "" : $ansi_magenta;
my $bold_stdout = $no_colors_stdout ? "" : $ansi_bold;
my $blink_stdout = $no_colors_stdout ? "" : $ansi_blink;
my $reset_stdout = $no_colors_stdout ? "" : $ansi_reset;
my $bunl_stdout = $no_colors_stdout ? "" : $ansi_bunl;
my $eunl_stdout = $no_colors_stdout ? "" : $ansi_eunl;

my $no_colors_stderr = ash_common::is_no_colors_stderr();
my $red_stderr = $no_colors_stderr ? "" : $ansi_red;
my $green_stderr = $no_colors_stderr ? "" : $ansi_green;
my $magenta_stderr = $no_colors_stderr ? "" : $ansi_magenta;
my $bold_stderr = $no_colors_stderr ? "" : $ansi_bold;
my $blink_stderr = $no_colors_stderr ? "" : $ansi_blink;
my $reset_stderr = $no_colors_stderr ? "" : $ansi_reset;
my $bunl_stderr = $no_colors_stderr ? "" : $ansi_bunl;
my $eunl_stderr = $no_colors_stderr ? "" : $ansi_eunl;

my $ash_path;
my $skip_paging;
my $quiet;

my $program_name = 'ash-config';
my $program_version = "$ash_common::ATLAS_SHELL_TOOLS_VERSION ($program_name program)";

# logging definitions
my %valid_levels = (
    "ALL" => 1,
    "TRACE" => 1,
    "DEBUG" => 1,
    "INFO" => 1,
    "WARN" => 1,
    "ERROR" => 1,
    "FATAL" => 1,
    "OFF" => 1
);
my @valid_level_keys = keys %valid_levels;

my %valid_streams = (
    "stdout" => 1,
    "stderr" => 1
);
my @valid_stream_keys = keys %valid_streams;

########## END GLOBAL INITIALIZATION ##########


########## BEGIN SUBROUTINES ##########

# Nothing here for now

########## END SUBROUTINES ##########


########## BEGIN COMMAND SUBROUTINES ##########

sub execute_command_activate {
    my $help_flag;
    GetOptions(
        'help|h' => \$help_flag
    ) or ash_common::getopt_failure_and_exit($program_name, "activate");

    if (defined $help_flag) {
        my $man_command = ash_common::get_man($skip_paging);
        unless (defined $man_command) {
            ash_common::error_output($program_name, "could not obtain \'man\' command");
            print STDERR "Please ensure a valid \'man\' command is on your path.\n";
            exit 1;
        }
        system("$man_command $program_name-activate");
        exit 0;
    }

    my $module_to_activate = shift @ARGV;
    unless (defined $module_to_activate) {
        ash_common::error_output($program_name . "-activate", "missing required argument");
        ash_common::getopt_failure_and_exit($program_name, "activate");
    }

    my %modules = get_module_to_status_hash($ash_path);
    unless (exists $modules{$module_to_activate}) {
        ash_common::error_output($program_name . "-activate", "no such module ${bold_stderr}${module_to_activate}${reset_stderr}");
        return 0;
    }

    # deactivate all other modules
    foreach my $module (keys %modules) {
        if ($modules{$module} == $ash_common::ACTIVATED) {
            ash_common::perform_deactivate($module, $ash_path, $program_name, $quiet);
        }
    }

    my $success = ash_common::perform_activate($module_to_activate, $ash_path, $program_name, $quiet);
    return $success;
}

sub execute_command_deactivate {
    my $help_flag;
    GetOptions(
        'help|h' => \$help_flag
    ) or ash_common::getopt_failure_and_exit($program_name, "deactivate");

    if (defined $help_flag) {
        my $man_command = ash_common::get_man($skip_paging);
        unless (defined $man_command) {
            ash_common::error_output($program_name, "could not obtain \'man\' command");
            print STDERR "Please ensure a valid \'man\' command is on your path.\n";
            exit 1;
        }
        system("$man_command $program_name-deactivate");
        exit 0;
    }

    my $module_to_deactivate = shift @ARGV;
    unless (defined $module_to_deactivate) {
        ash_common::error_output($program_name . "-deactivate", "missing required argument");
        ash_common::getopt_failure_and_exit($program_name, "deactivate");
    }

    my %modules = ash_common::get_module_to_status_hash($ash_path);
    unless (exists $modules{$module_to_deactivate}) {
        error_output($program_name . "-deactivate", "no such module ${bold_stderr}${module_to_deactivate}${reset_stderr}");
        return 0;
    }

    my $success = ash_common::perform_deactivate($module_to_deactivate, $ash_path, $program_name, $quiet);
    if ($success) {
        ash_common::remove_active_module_index($ash_path, $program_name, $quiet);
    }
    return $success;
}

sub execute_command_install {
    my $syminstall = 0;
    my $force_install = 0;
    my $skip_install = 0;
    my $install_deactivated = 0;
    my $alternate_name;
    my $help_flag;
    GetOptions(
        'symlink|s' => \$syminstall,
        'deactivated' => \$install_deactivated,
        'force' => \$force_install,
        'skip' => \$skip_install,
        'name=s' => \$alternate_name,
        'help|h' => \$help_flag
    ) or ash_common::getopt_failure_and_exit($program_name, "install");

    if (defined $help_flag) {
        my $man_command = ash_common::get_man($skip_paging);
        unless (defined $man_command) {
            ash_common::error_output($program_name, "could not obtain \'man\' command");
            print STDERR "Please ensure a valid \'man\' command is on your path.\n";
            exit 1;
        }
        system("$man_command $program_name-install");
        exit 0;
    }

    my $module_to_install = shift @ARGV;
    unless (defined $module_to_install) {
        ash_common::error_output($program_name . "-install", "missing required argument");
        ash_common::getopt_failure_and_exit($program_name, "install");
    }

    unless (-f $module_to_install || -l $module_to_install) {
        ash_common::error_output($program_name . "-install", "no such file ${bold_stderr}${module_to_install}${reset_stderr}");
        return 0;
    }

    my $modules_folder = File::Spec->catfile($ash_path, $ash_common::MODULES_FOLDER);

    # Create the module name, respecting the --name flag if present.
    my $module_basename;
    if (defined $alternate_name) {
        $module_basename = $alternate_name . $ash_common::MODULE_SUFFIX;
    }
    else {
        $module_basename = basename($module_to_install);
    }
    # TODO: figure out how to interpolate $MODULE_SUFFIX into this regex
    unless ($module_basename =~ /.*\.jar$/) {
        ash_common::error_output($program_name . "-install", "module must end with '.jar' extension");
        return 0;
    }
    $module_basename =~ s{$ash_common::MODULE_SUFFIX}{};

    # Handle the case where the module is already installed
    my %modules = ash_common::get_module_to_status_hash($ash_path);
    if (defined $modules{$module_basename}) {
        ash_common::warn_output($program_name, "module ${bold_stderr}${module_basename}${reset_stderr} is already installed");
        if ($skip_install) {
            print STDERR "Skipping installation.\n";
            return 0;
        }
        unless ($force_install) {
            my $overwrite = ash_common::prompt_yn("Overwrite?");
            unless ($overwrite) {
                print STDERR "Skipping installation.\n";
                return 0;
            }
        }
        ash_common::warn_output($program_name, "overwriting ${bold_stderr}${module_basename}${reset_stderr}");
    }

    # Construct the new module paths.
    # We create a path for both an activated and deactivated version.
    my $module_new_path =
        File::Spec->catfile($modules_folder, $module_basename . $ash_common::MODULE_SUFFIX);
    my $module_new_path_deactivated =
        File::Spec->catfile($modules_folder, $module_basename . $ash_common::DEACTIVATED_MODULE_SUFFIX);

    # If we made it here we are go to overwrite, so clean up any matching existing modules.
    unlink $module_new_path;
    unlink $module_new_path_deactivated;

    my $exitcode;
    if ($syminstall) {
        my $module_to_install_abs = Cwd::realpath($module_to_install);
        my $module_to_install_rel = File::Spec->abs2rel($module_to_install_abs, $modules_folder);

        if ($install_deactivated) {
            symlink($module_to_install_rel, $module_new_path_deactivated);
        }
        else {
            symlink($module_to_install_rel, $module_new_path);
        }
        $exitcode = $? >> 8;
    }
    else {
        if ($install_deactivated) {
            # FIXME this is vulnerable to code injection if a module is named something
            # like eg. '; echo vulnerable'. For this reason, this needs to be
            # refactored to use something safe, like File::Copy.
            system("cp $module_to_install $module_new_path_deactivated");
        }
        else {
            system("cp $module_to_install $module_new_path");
        }
        $exitcode = $? >> 8;
    }

    if ($exitcode) {
        print STDERR "${red_stderr}${bold_stderr}Installation failed.${reset_stderr} Operation exited with $exitcode.\n";
        return 0;
    }
    else {
        unless ($install_deactivated) {
            my %modules = get_module_to_status_hash($ash_path);
            foreach my $module (keys %modules) {
                if ($modules{$module} == $ash_common::ACTIVATED
                    && $module ne $module_basename) {
                    ash_common::perform_deactivate($module, $ash_path, $program_name, $quiet);
                }
            }
        }

        unless($install_deactivated) {
            ash_common::remove_active_module_index($ash_path, $program_name, $quiet);
            my $success = ash_common::generate_active_module_index($ash_path, $program_name, $quiet, 0);
            unless ($success) {
                ash_common::warn_output($program_name . "-install", "partial installation may not function properly");
            }
        }

        unless ($quiet) {
            print "Module ${green_stdout}${bold_stdout}${module_basename}${reset_stdout} installed.\n";
        }
    }

    return 1;
}

sub execute_command_list {
    my $help_flag;
    GetOptions(
        'help|h' => \$help_flag
    ) or ash_common::getopt_failure_and_exit($program_name, "list");

    if (defined $help_flag) {
        my $man_command = ash_common::get_man($skip_paging);
        unless (defined $man_command) {
            ash_common::error_output($program_name, "could not obtain \'man\' command");
            print STDERR "Please ensure a valid \'man\' command is on your path.\n";
            exit 1;
        }
        system("$man_command $program_name-list");
        exit 0;
    }

    my %modules = ash_common::get_module_to_status_hash($ash_path);
    my %symlinks = ash_common::get_module_to_symlink_hash($ash_path);
    my %targets = ash_common::get_module_to_target_hash($ash_path);

    unless (keys %modules) {
        ash_common::error_output($program_name . "-list", "found no installed modules");
        print STDERR "Try '${bold_stderr}${program_name} install /path/to/module.jar${reset_stderr}' to install a module.\n";
        return 0;
    }

    print "${bold_stdout}Installed ash modules:${reset_stdout}\n\n";
    # Sort the module names alphabetically. We use 'lc' to convert them to
    # lowercase, since by default 'sort' uses ASCII ordering.
    foreach my $module (sort {lc $a cmp lc $b} keys %modules) {
        my $status = $modules{$module};
        my $symlink = $symlinks{$module};
        my $target = $targets{$module};
        my $display = '    ';

        # if activated, place a star next to the name
        if ($status == 1) {
            $display = $display . '*';
        }
        else {
            $display = $display . ' ';
        }

        # choose an appropriate color for the display
        if ($status == $ash_common::ACTIVATED
            && ($symlink == $ash_common::REAL_FILE || $symlink == $ash_common::GOOD_SYMLINK)) {
            $display = $display . "${green_stdout}${bold_stdout}";
        }
        elsif ($symlink == $ash_common::BROKEN_SYMLINK) {
            $display = $display . "${red_stdout}${bold_stdout}";
        }

        # show the module name!
        $display = $display . " ${module}${reset_stdout}";

        # show a big message if the symlink is broken, blink if also activated
        if ($symlink == $ash_common::BROKEN_SYMLINK) {
            if ($status == $ash_common::ACTIVATED) {
                $display = $display . " ${bold_stdout}${blink_stdout}(BROKEN SYMLINK)${reset_stdout}";
            }
            else {
                $display = $display . " ${bold_stdout}(BROKEN SYMLINK)${reset_stdout}";
            }
        }

        # if we were a symlink, show the target after the module name
        if ($symlink != $ash_common::REAL_FILE) {
            $display = $display . " -> ${target}";
        }

        print "$display\n";
    }
    print "\n";

    return 1;
}

sub execute_command_log {
    my $ARGV_len = @ARGV;

    my $loglevel = '';
    my $logstream = '';
    my $reset = 0;
    my $help_flag;
    my $show;
    GetOptions(
        'reset' => \$reset,
        'set-level=s' => \$loglevel,
        'set-stream=s' => \$logstream,
        'show|s' => \$show,
        'help|h' => \$help_flag
    ) or ash_common::getopt_failure_and_exit($program_name, "log");

    if ($ARGV_len == @ARGV) {
        ash_common::error_output($program_name . "-log", "requires at least one option");
        ash_common::getopt_failure_and_exit($program_name, "log");
    }

    if (defined $help_flag) {
        my $man_command = ash_common::get_man($skip_paging);
        unless (defined $man_command) {
            ash_common::error_output($program_name, "could not obtain \'man\' command");
            print STDERR "Please ensure a valid \'man\' command is on your path.\n";
            exit 1;
        }
        system("$man_command $program_name-log");
        exit 0;
    }

    my $log_folder = File::Spec->catfile($ash_path, $ash_common::LOG4J_FOLDER);
    my $logfile_path = File::Spec->catfile($log_folder, $ash_common::LOG4J_FILE);
    my $current_level = ash_common::read_loglevel_from_file($logfile_path);
    my $current_stream = ash_common::read_logstream_from_file($logfile_path);

    if ($reset) {
        ash_common::reset_log4j($ash_path);
    }

    unless ($loglevel eq '') {
        if (exists($valid_levels{$loglevel})) {
            ash_common::replace_loglevel_in_file($logfile_path, $loglevel);
        }
        else {
            ash_common::error_output($program_name, "unrecognized log level ${bold_stderr}${loglevel}${reset_stderr}");
            return 0;
        }
    }

    unless ($logstream eq '') {
        if (exists($valid_streams{$logstream})) {
            ash_common::replace_logstream_in_file($logfile_path, $logstream);
        }
        else {
            ash_common::error_output($program_name, "unrecognized log stream ${bold_stderr}${logstream}${reset_stderr}");
            return 0;
        }
    }

    if ($show) {
        $current_level = ash_common::read_loglevel_from_file($logfile_path);
        $current_stream = ash_common::read_logstream_from_file($logfile_path);
        print "Current log level:    ${bold_stdout}${current_level}${reset_stdout}\n";
        print "Current log stream:   ${bold_stdout}${current_stream}${reset_stdout}\n";
    }

    return 1;
}

sub execute_command_reset {
    my $ARGV_len = @ARGV;

    my $help_flag;
    my $force_flag;
    my $all_flag;
    my $modules_flag;
    my $index_flag;
    my $presets_flag;
    my $log_flag;
    GetOptions(
        'force|f' => \$force_flag,
        'help|h' => \$help_flag,
        'all|a' => \$all_flag,
        'modules' => \$modules_flag,
        'index' => \$index_flag,
        'presets' => \$presets_flag,
        'log' => \$log_flag
    ) or ash_common::getopt_failure_and_exit($program_name, "reset");

    if (defined $help_flag) {
        my $man_command = ash_common::get_man($skip_paging);
        unless (defined $man_command) {
            ash_common::error_output($program_name, "could not obtain \'man\' command");
            print STDERR "Please ensure a valid \'man\' command is on your path.\n";
            exit 1;
        }
        system("$man_command $program_name-reset");
        exit 0;
    }

    if ($ARGV_len == @ARGV) {
        ash_common::error_output($program_name . "-reset", "requires at least one option");
        ash_common::getopt_failure_and_exit($program_name, "reset");
    }

    if (defined $modules_flag || defined $all_flag) {
        my $modules_folder = File::Spec->catfile($ash_path, $ash_common::MODULES_FOLDER);
        my %modules = ash_common::get_module_to_status_hash($ash_path);

        my $modules_length = keys %modules;
        if ($modules_length == 0) {
            ash_common::warn_output($program_name, "found no modules to uninstall");
        }
        else {
            foreach my $module (keys %modules) {
                my $confirmed = 1;
                unless ($force_flag) {
                     $confirmed = ash_common::prompt_yn("Uninstalling module $module. OK?");
                }
                if ($confirmed) {
                    ash_common::perform_uninstall($module, $ash_path, $program_name, $quiet);
                }
            }
        }
    }

    if (defined $presets_flag || defined $all_flag) {
        my $presets_folder = File::Spec->catfile($ash_path, $ash_common::PRESETS_FOLDER);
        my $confirmed = 1;
        unless ($force_flag) {
            $confirmed = ash_common::prompt_yn("Clearing saved presets at $presets_folder. OK?");
        }
        if ($confirmed) {
            rmtree($presets_folder);
            unless ($quiet) {
                print "Cleared presets.\n";
            }
        }
    }

    if (defined $log_flag || defined $all_flag) {
        my $log_folder = File::Spec->catfile($ash_path, $ash_common::LOG4J_FOLDER);
        my $logfile_path = File::Spec->catfile($log_folder, $ash_common::LOG4J_FILE);
        my $confirmed = 1;
        unless ($force_flag) {
            $confirmed = ash_common::prompt_yn("Resetting log parameters. OK?");
        }
        if ($confirmed) {
            ash_common::replace_loglevel_in_file($logfile_path, 'ERROR');
            ash_common::replace_logstream_in_file($logfile_path, 'stderr');
        }
    }

    if (defined $index_flag || defined $all_flag) {
        my $confirmed = 1;
        unless ($force_flag) {
            $confirmed = ash_common::prompt_yn("Removing active module index. OK?");
        }
        if ($confirmed) {
            ash_common::remove_active_module_index($ash_path, $program_name, $quiet);
        }
    }

    return 1;
}

sub execute_command_sync {
    my $help_flag;
    GetOptions(
        'help|h' => \$help_flag
    ) or ash_common::getopt_failure_and_exit($program_name, "sync");

    if (defined $help_flag) {
        my $man_command = ash_common::get_man($skip_paging);
        unless (defined $man_command) {
            ash_common::error_output($program_name, "could not obtain \'man\' command");
            print STDERR "Please ensure a valid \'man\' command is on your path.\n";
            exit 1;
        }
        system("$man_command $program_name-sync");
        exit 0;
    }

    ash_common::remove_active_module_index($ash_path, $program_name, $quiet);
    ash_common::generate_active_module_index($ash_path, $program_name, $quiet, 1);
}

sub execute_command_uninstall {
    my $allflag;
    my $help_flag;
    GetOptions(
        'all|a' => \$allflag,
        'help|h' => \$help_flag
    ) or ash_common::getopt_failure_and_exit($program_name, "uninstall");

    if (defined $help_flag) {
        my $man_command = ash_common::get_man($skip_paging);
        unless (defined $man_command) {
            ash_common::error_output($program_name, "could not obtain \'man\' command");
            print STDERR "Please ensure a valid \'man\' command is on your path.\n";
            exit 1;
        }
        system("$man_command $program_name-uninstall");
        exit 0;
    }

    if (defined $allflag) {
        my %modules = ash_common::get_module_to_status_hash($ash_path);
        foreach my $module (keys %modules) {
            ash_common::perform_uninstall($module, $ash_path, $program_name, $quiet);
        }
        return 1;
    }

    my $module_to_uninstall = shift @ARGV;
    unless (defined $module_to_uninstall) {
        ash_common::error_output($program_name . "-uninstall", "missing required argument");
        ash_common::getopt_failure_and_exit($program_name, "uninstall");
    }

    my %modules = ash_common::get_module_to_status_hash($ash_path);
    my @activated_modules = ash_common::get_activated_modules(\%modules);
    my $activated_module = $activated_modules[0];
    my $success = ash_common::perform_uninstall($module_to_uninstall, $ash_path, $program_name, $quiet);
    unless ($success) {
        return 0;
    }

    if (defined $activated_module) {
        if ($module_to_uninstall eq $activated_module) {
            ash_common::remove_active_module_index($ash_path, $program_name, $quiet);
        }
    }

    return 1;
}

########## END COMMAND SUBROUTINES ##########


########## BEGIN EXECUTION LOGIC ##########

$ash_path = ash_common::create_data_directory();

my $help_argument;
Getopt::Long::Configure(qw(no_ignore_case_always));
GetOptions(
    "no-pager" => \$skip_paging,
    "help|h:s" => \$help_argument,
    "version|V" => sub { print "$program_version\n"; exit 0; },
    "quiet|q" => \$quiet,
    # This callback occurs the first time we see a non-option argument.
    # In our case, this will be the subcommand.
    "<>" => sub {
        my($arg) = @_;
        if ($arg =~ m{^-}) {
            unless ($arg eq '-') {
                die "FATAL error: unhandled global option $arg";
            }
        }
        # add the subcommand to the front of ARGV
        unshift @ARGV, $arg;
        die "!FINISH";
    }
) or ash_common::getopt_failure_and_exit($program_name);

# Handle the cases where the user supplied a --help flag
# 1) --help -> print the default help menu and exit
# 2) --help=TOPIC -> print the TOPIC help menu and exit
if (defined $help_argument) {
    my $man_command = ash_common::get_man($skip_paging);
    unless (defined $man_command) {
        ash_common::error_output($program_name, "could not obtain \'man\' command");
        print STDERR "Please ensure a valid \'man\' command is on your path.\n";
        exit 1;
    }
    my $exitcode;
    if ($help_argument eq '') {
        system("$man_command $program_name");
        $exitcode = $? >> 8;
    }
    else {
        system("$man_command $program_name-$help_argument");
        $exitcode = $? >> 8;
    }
    if ($exitcode != 0) {
            exit 1;
    }
    exit 0;
}

# All global options have been processed, so shift the subcommand off of ARGV
my $subcommand = shift @ARGV;

unless (defined $subcommand) {
    ash_common::error_output($program_name, "missing required command or option");
    print STDERR "Try '${bold_stderr}${program_name} --help${reset_stderr}' for more information.\n";
    exit 1;
}

my $success = 0;
if ($subcommand eq "activate") {
    $success = execute_command_activate();
}
elsif ($subcommand eq "deactivate") {
    $success = execute_command_deactivate();
}
elsif ($subcommand eq "install") {
    $success = execute_command_install();
}
elsif ($subcommand eq "list") {
    $success = execute_command_list();
}
elsif ($subcommand eq "log") {
    $success = execute_command_log();
}
elsif ($subcommand eq "reset") {
    $success = execute_command_reset();
}
elsif ($subcommand eq "sync") {
    $success = execute_command_sync();
}
elsif ($subcommand eq "uninstall") {
    $success = execute_command_uninstall();
}
# These subcommands are "hidden", they are used by the completion script
# to generate autocomplete suggestions.
elsif ($subcommand eq "__completion_ash__") {
    $success = ash_common::completion_ash($ash_path, \@ARGV);
}
else {
    ash_common::error_output($program_name, "no such command ${bold_stderr}${subcommand}${reset_stderr}");
    print STDERR "Try '${bold_stderr}${program_name} --help${reset_stderr}' for more information.\n";
    exit 127;
}

if ($success) {
    exit 0;
}
else {
    exit 1;
}

########## END EXECUTION LOGIC ##########
