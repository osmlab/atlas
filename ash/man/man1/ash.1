.\"     Title: ash
.\"    Author: Lucas Cram
.\"    Source: ash 1.0.0
.\"  Language: English
.\"
.TH "ASH" "1" "1 December 2018" "ash 1\&.0\&.0" "Atlas Shell Tools Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------

.SH "NAME"
.sp
ash \-- The main Atlas Shell Tools command interface

.SH "SYNOPSIS"
.sp
.nf
\fIash\fR [\-\-no-pager] [\-\-help[=<\fIcommand\fR>]]
\fIash\fR [\-V | \-\-version]
\fIash\fR [\-\-no-pager] [\-l | \-\-list]
\fIash\fR [\-\-class\-of=<\fIcommand\fR>]
\fIash\fR [\-\-quiet] cfg:preset <directive> [args...]
\fIash\fR [\-\-no\-pager] [\-\-memory=<amount>] [\-\-preset=<preset>]
    [\-\-save\-preset=<new\-preset>] <\fIcommand\fR> [arg...]
.fi

.SH "DESCRIPTION"
.sp
\fBash\fR is an easy\-to\-use wrapper for launching command line tools extending
the \fBAbstractOSMSubcommand\fR class in \fBAtlas\fR. It provides a simple
interface to both find and run any commands contained within a JARfile, known as
a module in \fBash\fR lingo.
\fBash\fR also implements a robust preset management system, which can save
you tons of typing for commands that require a lot of options. See the \fBPRESETS\fR
section for more on this topic.
.sp
For more advanced module management capabilites and other installation related
commands, please see \fBash\-config\fR(1).

.SH "OPTIONS"

.PP
<\fIcommand\fR>
.RS 4
This indicates a subcommand. A list of available subcommands can be
seen with the \fB--list\fR option.
.RE

.PP
\fBcfg:preset\fR <directive> [args...]
.RS 4
This special subcommand puts \fBash\fR into preset configuration mode \- allowing
the user to run a preset configuration directive with some arguments. When the
option parser sees \fBcfg:preset\fR, it stops and passes any remaining ARGV elements into the
preset configuration engine. See the \fBPRESETS\fR section for more information.
.RE

.PP
\fB\-\-class\-of\fR=<\fIcommand\fR>
.RS 4
Show the full classname of a given command and then exit.
.RE

.PP
\fB\-\-help\fR[=<\fIcommand\fR>]\fR
.RS 4
Show the help menu for a given command. If no command is given, show
a general help menu and then exit.
.RE

.PP
\fB\-\-list\fR, \fB-l\fR
.RS 4
Display a list of all available commands and exit. Command name collision is
resolved deterministically at module activation time. The resolution exists at
the \fBash\fR wrapper level only, and is not reflected in the actual command
class files.
.RE

.PP
\fB\-\-memory\fR=<amount>, \fB\-m\fR<amount>
.RS 4
Set the maximum memory pool size for the JVM that runs your command.
<amount> should be specified in bytes. \fB--memory\fR also understands
shorthand for metric prefixes, eg. 1024K, 512M, 4G, etc.
.RE

.PP
\fB\-\-no\-pager\fR
.RS 4
Disable pagination for all documentation.
.RE

.PP
\fB\-\-preset\fR=<preset>, \fB\-p\fR<preset>
.RS 4
Apply the given preset before running <\fIcommand\fR>. See the \fBPRESETS\fR section
for more information.
.RE

.PP
\fB\-\-quiet\fR, \fB\-q\fR
.RS 4
Suppress non-essential \fBash\fR output.
.RE

.PP
\fB\-\-save\-preset\fR=<new\-preset>
.RS 4
Save the command ARGV to <new\-preset> before running <\fIcommand\fR>. If
\fB\-\-preset\fR is also supplied, the save operation will occur after the
argument to \fB\-\-preset\fR is applied. So <new\-preset> will include ARGV
elements inserted by the \fB\-\-preset\fR application in addition to those
directly supplied by the user. See the \fBPRESETS\fR section for more information.
.RE

.PP
\fB\-\-version\fR, \fB-V\fR
.RS 4
Show the \fBash\fR version info and then exit.
.RE
.sp

.SH "EXAMPLES"
.sp
Run a command called MyCommand with some args and options:
.sp
.RS 4
$ ash MyCommand \-\-opt1 arg1 \-\-opt2=optarg2 arg2 arg3
.RE
.sp
See the manual page for MyCommand:
.sp
.RS 4
$ ash \-\-help MyCommand
.RE
.sp
See a list of all available commands:
.sp
.RS 4
$ ash \-\-list
.RE
.sp
Run MyCommand with preset p1:
.sp
.RS 4
$ ash \-\-preset=p1 MyCommand arg1 \-\-opt2=overridePresetArg
.RE
.sp
Edit preset p1 for MyCommand:
.sp
.RS 4
$ ash cfg:preset edit:MyCommand p1
.RE

.SH "PRESETS"
.sp
\fBash\fR features a robust preset management system. Presets provide a way to save
command options and their arguments for future application or modification.
The preset interface is divided into 3 tiers. Each tier supports an increasing
number of potential use cases at the cost of added complexity for the user. The
tiers are designed such that you can stop at any tier you feel comfortable using
\- without needing to understand how the next tier up works. Each tier builds
on concepts introduced in the previous tier.

The three interface tiers are:
.sp
.RS 4
\fBTier 1)\fR Basic preset creation and use with the \fB\-\-save\-preset\fR and \fB\-\-preset\fR options.

\fBTier 2)\fR More precise preset management with \fBcfg:preset\fR, including editing, copying, etc.

\fBTier 3)\fR Preset namespace management with \fBcfg:preset namespace\fR.
.RE

\fBTIER 1\fR
.RS 4
Tier 1 provides a simple, lightweight interface for preset usage through the
\fB\-\-preset\fR=\fIname\fR and \fB\-\-save\-preset\fR=\fInew\-name\fR options, where
\fIname\fR is the name of the preset you would like to apply and \fInew\-name\fR is
the name of the preset you would like to create.
.sp
When running a command with the \fB\-\-preset\fR=\fIname\fR option,
\fBash\fR checks the list of saved presets associated with that command.
If one of those presets matches with \fIname\fR, \fBash\fR uses that preset. If
\fBash\fR cannot find a match with \fIname\fR, it displays the list and exits
with an error.
.sp
When running a command with the \fB\-\-save\-preset\fR=\fInew\-name\fR option,
\fBash\fR attempts to save the current ARGV to a new preset called \fInew\-name\fR.
If \fInew\-name\fR already exists, \fBash\fR will exit with an error.
.sp
If both \fB\-\-preset\fR=\fIname\fR and \fB\-\-save\-preset\fR=\fInew\-name\fR
are applied at the same time, \fBash\fR will attempt to apply \fIname\fR before
saving \fInew\-name\fR. This allows you to easily save new presets that iterate
on a previously created preset.
.sp
Note that preset names are bound to the target command at save\-time \- 
a preset name without its command context is meaningless. This means that preset
"p1" for "ExampleCommand" and preset "p1" for "MyCommand" may contain
completely different values!
.sp
Let's look at an example of the Tier 1 interface in action.
We will run a command called "MyCommand" and assume preset "p1" does not yet exist:
.sp
.RS 4
$ ash \-\-save\-preset=p1 MyCommand arg1 arg2 \-\-opt1 \-\-opt2=opt2Arg
.RE
.sp
This will save a preset "p1" for "MyCommand" with contents ["\-\-opt1", "\-\-opt2=opt2Arg"]
and then run the command. Note that the preset engine only saves options, and so will
automatically discard any ARGV element that does not look like an option. For this reason,
you \fImust\fR use the long option '=' syntax for specifying option arguments when saving
a preset.
.sp
Now that you have saved preset "p1" for "MyCommand", you can apply it like:
.sp
.RS 4
$ ash \-\-preset=p1 MyCommand arg1 arg2
.RE
.sp
This will run the exact same command as before, but it saves us from having
to type out \-\-opt1, \-\-opt2 with their arguments. In addition to simply applying
a preset verbatim, you can also override a saved option by specifying it again
on the command line:
.sp
.RS 4
$ ash \-\-preset=p1 MyCommand arg1 arg2 \-\-opt2=OverrideOpt2Arg
.RE
.sp
This will run the same command as the above 2 examples, except it will override
the preset value of \-\-opt2 with your new value "OverrideOpt2Arg".
.sp
Finally, you can extend presets by applying and saving at the same time. Here,
we apply our preset "p1" while also saving a new preset called "p2", based off
the contents of "p1":
.sp
.RS 4
$ ash \-\-preset=p1 \-\-save\-preset=p2 MyCommand arg1 arg2 --opt2=OverrideOpt2Arg --opt3
.RE
.sp
The new preset "p2" will contain the following contents:
["\-\-opt1", "\-\-opt2=opt2Arg", "\-\-opt2=OverrideOpt2Arg", "\-\-opt3"]. Even though
\-\-opt2 is repeated, this is OK! When multiple instances of the same option are
supplied, the option parser will use ARGV's rightmost instance of that option.
.RE
.sp

\fBTIER 2\fR
.RS 4
Tier 2 provides more precise preset management using a special argument to \fBash\fR
called \fBcfg:preset\fR. \fBcfg:preset\fR takes a mandatory \fIdirective\fR,
which is just a verb specifying a configuration action. Note that many of the
directives require additional command context, which is specified using the ':'
operator (recall that preset names are meaningless without an associated command).
Below are the available directives:

.sp
.RS 4
\fBsave\fR:\fIcommand\fR <name> <args...>
.RS 4
Save a preset <name> for \fIcommand\fR without actually running the command.
<args...> is a sequence of options to be saved in the preset.
Again, recall that you must use the long option '=' syntax for specifying option
arguments when saving a preset. The following example saves preset "p1" to command
"MyCommand" with some options --opt1 and --opt2=opt2Arg:
.sp
.RS 4
$ ash cfg:preset save:MyCommand p1 --opt1 --opt2=opt2Arg
.RE
.RE
.RE

.sp
.RS 4
\fBshow\fR:\fIcommand\fR [name]
.RS 4
Show all presets for a given \fIcommand\fR, or show contents of preset [name]
for \fIcommand\fR. The following example shows the contents of preset "p1"
for command "MyCommand":
.sp
.RS 4
$ ash cfg:preset show:MyCommand p1
.RE
.sp
Omitting the "p1" argument would have shown all presets for "MyCommand".
.RE
.RE

.sp
.RS 4
\fBremove\fR:\fIcommand\fR [name]
.RS 4
Remove all presets for a given command, or remove the preset [name] for
\fIcommand\fR. The following example removes all presets for command "MyCommand",
then removes preset "p1" for command "AnotherCommand":
.sp
.RS 4
$ ash cfg:preset remove:MyCommand

$ ash cfg:preset remove:AnotherCommand p1
.RE
.sp
.RE
.RE

.sp
.RS 4
\fBedit\fR:\fIcommand\fR <name>
.RS 4
Edit preset <name> for \fIcommand\fR. If <name> does not exist, then it will be
created when the edit is successfully saved. The default preset editor is \fBvim\fR,
but this can be changed by setting the \fBEDITOR\fR environment variable. The following
example will edit preset "p1" for command "MyCommand":
.sp
.RS 4
$ ash cfg:preset edit:MyCommand p1
.RE
.RE
.RE

.sp
.RS 4
\fBcopy\fR:\fIcommand\fR <source> <destination>
.RS 4
Copy \fIcommand\fR preset <source> into new preset <destination>.
<destination> must not already exist, else the copy will fail. The following example
copies the preset "p1" into new preset "p2", for command "MyCommand":
.sp
.RS 4
$ ash cfg:preset copy:MyCommand p1 p2
.RE
.sp
The \fBcopy\fR directive is useful in combination with the \fBedit\fR directive \-
when you want to have multiple versions of a large preset, each with some minor differences.
.RE
.RE

.sp
.RS 4
\fBnamespace\fR <subdirective> [namespace]
.RS 4
Execute a <subdirective> on a given preset [namespace]. Available subdirectives
are \fBlist\fR, \fBuse\fR, \fBcreate\fR, and \fBremove\fR. Preset namespaces \-
and the \fBnamespace\fR directive \- are explained in more detail in the
\fBTIER 3\fR section found below.
.RE
.RE
.RE
.sp

\fBTIER 3\fR
.RS 4
Tier 3 provides preset namespaces. A namespace creates an enclosing
scope for the presets associated with each command. For example, preset
"p1" for command "MyCommand" under "namespace1" and preset "p1" for command
"MyCommand" under "namespace2" may have completely different contents. Up to
this point, we have been working under the default namespace, appropriately
called "default". You can create and switch to new namespaces using the
\fBcfg:preset namespace\fR directive, which takes a subdirective to denote
the desired action. The available subdirectives are below:
.sp

.RS 4
\fBlist\fR
.RS 4
List all namespaces, highlighting the current namespace with a "*". An example
usage would look like:
.sp
.RS 4
$ ash cfg:preset namespace list
.RE
.RE
.RE
.sp

.RS 4
\fBuse\fR <namespace>
.RS 4
Switch to <namespace>, throwing an error if <namespace> does not exist. Any new
presets you create will now be saved under <namespace>, and presets you apply
will be sourced from <namespace>. The following example switches to a namespace
called "namespace1":
.sp
.RS 4
$ ash cfg:preset namespace use namespace1
.RE
.RE
.RE

.RS 4
\fBcreate\fR <namespace>
.RS 4
Create a new <namespace>, throwing an error if <namespace> already exists. This
will not actually switch to the new namespace. The following example creates a
namespace called "namespace1":
.sp
.RS 4
$ ash cfg:preset namespace create namespace1
.RE
.RE
.RE

.RS 4
\fBremove\fR <namespace>
.RS 4
Delete a <namespace>, including all associated presets. The \fBremove\fR will
fail if <namespace> does not exist, if <namespace> is currently in-use, or if
<namespace> is the default namespace. The following example removes a namespace
called "namespace1":
.sp
.RS 4
$ ash cfg:preset namespace remove namespace1
.RE
.RE
.RE

.RE
.sp

.SH "TERMINAL AND ENVIRONMENT"
.sp
\fBash\fR pages the output of the various help messages using a combination of
\fBless\fR and \fBman\fR. Subcommand help pages are piped through \fBless\fR
by default, but this can be overridden with the \fBPAGER\fR environment variable.
The actual \fBash\fR manual page (which you are currently reading) is displayed
using \fBman\fR. To disable paged output for all documentation, try the
\fB\-\-no\-pager\fR option.
.sp
\fBash\fR uses formatted output when appropriate. To change this behavior,
\fBash\fR checks for existence of the following environment variables:
.sp
.RS 4
\fBNO_COLOR\fR \-
Disable all special formatted output. Other popular CLI tools also
respect this variable. See https://no\-color.org/
.sp
\fBASH_NO_COLOR\fR \-
Disable special formatted output for \fBash\fR and \fBash-config\fR only.
.sp
\fBASH_USE_COLOR\fR \-
Enable special formatted output. Overrides the setting of \fBNO_COLOR\fR and \fBASH_NO_COLOR\fR.
.sp
.RE
\fBash\fR stores program data in compliance with the XDG Base Directory
specification, ie. at $HOME/.local/share/ash. It also respects the
\fBXDG_DATA_HOME\fR environment variable - if set, \fBash\fR will store program
data at the base path specified by that variable. See \fBash\-plumbing\fR(5) for
more information.

.SH "SEE ALSO"
.sp
\fBash-config\fR(1)

.SH "AUTHOR"
.sp
This program was written by Lucas Cram <lucaspcram@gmail.com>.
Please report any bugs you find.

.SH "BUGS"
.sp
Shell variable quote interactions do not quite work correctly within \fBash\fR.
All variables end up being passed forward into the JVM, even those
surrounded with single quotes. Eg:
.sp
.RS 4
$ ash MyProgram '$SHELL'
.RE
.sp
This will end up passing the value of $SHELL forward as an argument to MyProgram
when in reality it should be passing the literal text $SHELL.
