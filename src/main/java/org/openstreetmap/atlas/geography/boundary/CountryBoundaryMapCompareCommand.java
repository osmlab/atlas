package org.openstreetmap.atlas.geography.boundary;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.junit.Assert;
import org.openstreetmap.atlas.geography.MultiPolygon;
import org.openstreetmap.atlas.streaming.resource.File;
import org.openstreetmap.atlas.utilities.maps.MultiMap;
import org.openstreetmap.atlas.utilities.runtime.Command;
import org.openstreetmap.atlas.utilities.runtime.CommandMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vividsolutions.jts.geom.Envelope;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.index.strtree.STRtree;

/**
 * Compares given {@link CountryBoundaryMap}s to find if there are any differences between them.
 *
 * @author mkalender
 */
public class CountryBoundaryMapCompareCommand extends Command
{
    private static final Logger logger = LoggerFactory
            .getLogger(CountryBoundaryMapCompareCommand.class);

    // Parameters
    private static final Switch<CountryBoundaryMap> BASELINE_MAP = new Switch<>("baseline",
            "Path to file generated by CountryBoundaryMap to use as a baseline",
            path -> CountryBoundaryMap.fromPlainText(new File(path)), Optionality.REQUIRED);
    private static final Switch<CountryBoundaryMap> OTHER_MAP = new Switch<>("new",
            "Path to file generated by CountryBoundaryMap to compare against baseline",
            path -> CountryBoundaryMap.fromPlainText(new File(path)), Optionality.REQUIRED);

    static boolean areSTRtreesEqual(final STRtree baselineTree, final STRtree newTree)
    {
        final MultiMap<Geometry, Envelope> baselineCells = new MultiMap<>();
        CountryBoundaryMap.collectCells(baselineTree.getRoot(), baselineCells);

        final MultiMap<Geometry, Envelope> newCells = new MultiMap<>();
        CountryBoundaryMap.collectCells(newTree.getRoot(), newCells);

        if (baselineCells.size() != newCells.size())
        {
            logger.error("Given trees has different number of cells. Baseline {} vs new {}.",
                    baselineCells.size(), newCells.size());
            return false;
        }

        // Go over each geometry and compare envelopes attached to it
        for (final Geometry geometry : baselineCells.keySet())
        {
            final List<Envelope> baselineEnvelopes = baselineCells.get(geometry);
            final List<Envelope> newEnvelopes = newCells.get(geometry);

            if (baselineEnvelopes == null || newEnvelopes == null)
            {
                logger.error("One of the tree is null for geometry {}. Baseline {} vs new {}.",
                        geometry, baselineEnvelopes == null, newEnvelopes == null);
                return false;
            }

            if (baselineEnvelopes.size() != newEnvelopes.size())
            {
                logger.error(
                        "Trees have different number of envelopes for geometry {}. Baseline {} vs new {}.",
                        geometry, baselineEnvelopes.size(), newEnvelopes.size());
                return false;
            }

            logger.debug("Comparing {} envelopes.", baselineEnvelopes.size());

            // Go over each envelope and try to find it in the other tree
            boolean foundEqual = baselineEnvelopes.stream().parallel()
                    .allMatch(baselineEnvelope -> newEnvelopes.stream()
                            .anyMatch(envelope -> envelope.equals(baselineEnvelope)));

            if (!foundEqual)
            {
                logger.error(
                        "At least one envelope couldn't be found in the new tree for geometry {}.",
                        geometry);
                return false;
            }

            foundEqual = newEnvelopes.stream().parallel().allMatch(newEnvelope -> baselineEnvelopes
                    .stream().anyMatch(envelope -> envelope.equals(newEnvelope)));

            if (!foundEqual)
            {
                logger.error("New tree has at least one additional envelope for geometry {}.",
                        geometry);
                return false;
            }
        }

        return true;
    }

    public static void main(final String[] args)
    {
        new CountryBoundaryMapCompareCommand().run(args);
    }

    @Override
    protected int onRun(final CommandMap command)
    {
        // Read inputs
        final CountryBoundaryMap baselineMap = (CountryBoundaryMap) command.get(BASELINE_MAP);
        final CountryBoundaryMap newMap = (CountryBoundaryMap) command.get(OTHER_MAP);

        // Compare loaded countries
        final Set<String> baselineCountries = baselineMap.getLoadedCountries();
        final Set<String> newCountries = newMap.getLoadedCountries();
        baselineCountries.forEach(country -> Assert.assertTrue(
                String.format("New map is missing country %s.", country),
                newCountries.contains(country)));
        newCountries.forEach(country -> Assert.assertTrue(
                String.format("New map has additional country %s.", country),
                baselineCountries.contains(country)));
        Assert.assertEquals("Map sizes are not equal.", baselineMap.size(), newMap.size());

        // Compare country boundaries
        baselineMap.getLoadedCountries()
                .forEach(country -> baselineMap.countryBoundary(country).forEach(countryBoundary ->
                {
                    final List<MultiPolygon> newBoundaries = newMap.countryBoundary(country)
                            .stream().map(CountryBoundary::getBoundary)
                            .collect(Collectors.toList());
                    Assert.assertTrue(
                            String.format("New map is missing a boundary for %s.", country),
                            newBoundaries.contains(countryBoundary.getBoundary()));
                }));

        newMap.getLoadedCountries()
                .forEach(country -> newMap.countryBoundary(country).forEach(countryBoundary ->
                {
                    final List<MultiPolygon> baselineBoundaries = baselineMap
                            .countryBoundary(country).stream().map(CountryBoundary::getBoundary)
                            .collect(Collectors.toList());
                    Assert.assertTrue(
                            String.format("New map has additional boundary for %s.", country),
                            baselineBoundaries.contains(countryBoundary.getBoundary()));
                }));

        // Compare raw index
        Assert.assertFalse("One of the maps is missing raw index.",
                baselineMap.getRawIndex() == null ^ newMap.getRawIndex() == null);
        Assert.assertEquals("Node capacity of raw indeces are not equal.",
                baselineMap.getRawIndex().getNodeCapacity(),
                newMap.getRawIndex().getNodeCapacity());
        Assert.assertEquals("Depth of raw indeces are not equal.",
                baselineMap.getRawIndex().depth(), newMap.getRawIndex().depth());
        Assert.assertEquals("Size of raw indeces are not equal.", baselineMap.getRawIndex().size(),
                newMap.getRawIndex().size());
        Assert.assertTrue("Raw indeces are not equal.",
                areSTRtreesEqual(baselineMap.getRawIndex(), newMap.getRawIndex()));

        // Compare grid index
        Assert.assertFalse("One of the maps is missing grid index.",
                baselineMap.getGridIndex() == null ^ newMap.getGridIndex() == null);
        Assert.assertEquals("Node capacity of grid indeces are not equal.",
                baselineMap.getGridIndex().getNodeCapacity(),
                newMap.getGridIndex().getNodeCapacity());
        Assert.assertEquals("Depth of grid indeces are not equal.",
                baselineMap.getGridIndex().depth(), newMap.getGridIndex().depth());
        Assert.assertEquals("Size of grid indeces are not equal.",
                baselineMap.getGridIndex().size(), newMap.getGridIndex().size());
        Assert.assertTrue("Grid indeces are not equal.",
                areSTRtreesEqual(baselineMap.getGridIndex(), newMap.getGridIndex()));

        logger.info("Compared given maps and found no difference.");
        return 0;
    }

    @Override
    protected SwitchList switches()
    {
        return new SwitchList().with(BASELINE_MAP, OTHER_MAP);
    }
}
